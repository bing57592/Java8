package com.ysu.scala.unit6.implicitclass

/**
  * 隐式类: 用implicit声明的类.
  * 隐式类的功能非常强大, 同样可以拓展类的功能, 比前面使用隐式转换丰富类库功能更加方便, 在集合中隐式类
  * 会发挥重要的作用. 隐式类具有如下特点:
  *  1. 其所带的构造参数有且只能有一个
  *  2. 隐式类必须被定义在 "类" 或 "伴生对象" 或 "包对象" 里, 即隐式类不能是顶级的(top-level-objects).
  *  3. 隐式类不能使case class (case class在后续介绍)
  *  4. 作用域内不能有与之相同的名称和标识符.
  *
  * 隐式的转换时机:
  *  1. 当方法中的参数和类型与目标类型不一致时
  *  2. 当对象调用所在类中不存在的方法或成员时, 编译器会自动将对象进行隐式转换(根据类型)
  *
  * 隐式解析机制:
  *  1. 首先会在当前代码作用域下查找隐式实体(隐式方法, 隐式类, 隐式对象).(一般是这种情况)
  *  2. 如果第一条规则查找隐式实体失败, 则会继续在隐式参数的类型的作用域里查找. 类型的作用域是指与该
  * ---类型相关联的全部伴生模块, 一个隐式实体的类型T 它的查找范围如下(第二种情况范围广而且复杂, 在
  * ---使用时, 应当尽量避免出现)
  * -- a) 如果T 被定义成T with A with B with C, 那么A, B, C都是T的部分, 在T的隐式解析过程中, 它
  * ------们的伴生对象都会被搜索
  * -- b) 如果T 是参数化类型, 那么类型参数和与类型参数相关联的部分都算作T的部分, 比如List[String]的
  * ------隐式搜索会搜索List 的伴生对象和String 的伴生对象.
  * -- c) 如果T 是一个单例类型p.T, 即T 是属于某个p 对象内, 那么这个p 对象也会被搜索.
  * -- d) 如果T 是一个类型注入S#T, 那么S 和T 都会被搜索.
  * 在进行隐式转换时, 需要遵守两个基本前提:
  *  1. 不能存在二义性
  *  2. 隐式操作不能嵌套
  *
  * @Author bing57592 
  * @Date 2018-12-07 12:15
  */
object Main {
  def main(args: Array[String]): Unit = {
    implicit class DB1(val m: MySQL1) {
      def addSuffix(): String = {
        m + " scala"
      }
    }

    val mysql1 = new MySQL1
    mysql1.sayOk()
    println(mysql1.addSuffix())
  }
}
